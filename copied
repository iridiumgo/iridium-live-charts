templ (cw *ChartWidget) Component() {
	<div class="bg-card text-card-foreground rounded-xl flex flex-col border shadow-sm p-4 h-60">
		<h3 class="text-lg font-bold mb-2">Test TitleStr</h3>
		<div class="w-full h-40">
			<canvas id="chart" class="w-full h-full"></canvas>
		</div>
	</div>
	<script src="https://cdn.jsdelivr.net/npm/chart.js@3.3.2"></script>
	<script src="https://cdn.jsdelivr.net/npm/luxon@1.27.0"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.0.0"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming@2.0.0"></script>
	<script src="/static/assets/js/chart.js"></script>
}


mux.HandleFunc(
		"/events", func(w http.ResponseWriter, r *http.Request) {
			w.Header().Set("Content-Type", "text/event-stream; charset=utf-8")
			w.Header().Set("Cache-Control", "no-cache, no-transform")
			w.Header().Set("Connection", "keep-alive")
			// Optional but helpful behind certain proxies/reverse proxies:
			w.Header().Set("X-Accel-Buffering", "no")
			// Set CORS only if you actually need cross-origin:
			// w.Header().Set("Access-Control-Allow-Origin", "*")

			flusher, ok := w.(http.Flusher)
			if !ok {
				http.Error(w, "Streaming unsupported", http.StatusInternalServerError)
				return
			}

			// Let the browser know how long to wait before reconnect attempts.
			// This line defines the retry interval for future automatic reconnects.
			fmt.Fprint(w, "retry: 5000\n\n")
			flusher.Flush()

			// Initial connection event
			fmt.Fprint(w, "data: {\"type\": \"connected\"}\n\n")
			flusher.Flush()

			ticker := time.NewTicker(1000 * time.Millisecond)
			defer ticker.Stop()

			for {
				select {
				case <-ticker.C:
					value := rand.Intn(200)
					date := time.Now().UTC().Format(time.RFC3339Nano)

					// Each SSE event ends with an extra newline
					fmt.Fprintf(w, "data: {\"date\": \"%s\", \"value\": %d}\n\n", date, value)
					flusher.Flush()

				case <-r.Context().Done():
					return
				}
			}
		},
	)